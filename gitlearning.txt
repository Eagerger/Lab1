core.safecrlf


Git提供了一个换行符检查功能（core.safecrlf），可以在提交时检查文件是否混用了不同风格的换行符。这个功能的选项如下：

false - 不做任何检查
warn - 在提交时检查并警告
true - 在提交时检查，如果发现混用则拒绝提交
建议使用最严格的 true 选项。

core.autocrlf

假如你正在Windows上写程序，又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。这是因为Windows使用回车和换行两个字符来结束一行，而Mac和Linux只使用换行一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。

Git可以在你提交时自动地把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用core.autocrlf来打开此项功能，如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF：

$ git config --global core.autocrlf true
Linux或Mac系统使用LF作为行结束符，因此你不想 Git 在签出文件时进行自动的转换；当一个以CRLF为行结束符的文件不小心被引入时你肯定想进行修正，把core.autocrlf设置成input来告诉 Git 在提交时把CRLF转换成LF，签出时不转换：

$ git config --global core.autocrlf input
这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。

如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中：

$ git config --global core.autocrlf false

2.为什么要创建其他分支？
看到这个标题，读者可能会有疑问：不是已经有一个master分支了吗，为什么还要另外创建
其他分支？我们每次commit就好，假如是远程协作的话，就都Push到远程服务器上，有冲突
就解决冲突，然后每个人在pull一下服务器上的代码不就好了，另外创建新分支好像没什么
必要吧？
答：我以前也是这样想的，在上一家公司，我和另外的同事就是这样干的...把东西都丢到
master分支上，感觉没什么不对，当然，这种做法是可以的，项目小可以，整个项目就一个master分支，
但是这样做其实并不好！下面列举两点吧：
第一点，我们一般的项目都是一步步迭代升级的，一般都会有大版本和小版本的更新，
大版本更新一般是改头换面的一个更新，比如UI大改或者架构大改之类的，然后版本是：v2.0.0这样；
而小版本的更新一般是一些细节的小改，比如UI修改和bug的修复，或者优化等，然后版本是:v2.0.11这样；
只有一条master分支，意味着你的分支线会非常非常的长，假如你发布了第二个大版本，而用户反馈
你的第一个版本有一个很严重的Bug，你要切回之前的版本，够呛的哈！
第二点，效率问题，假如某一次提交后出现冲突了，而这个冲突很难解决，那么就会卡在这里，
那么就无法向后再开发了，又或者说master上的分支出现了很大的问题，同样也无法接着开发。
当然，不好的地方远远不止上面两个，我们得想办法来解决这个问题，而一个简单而有效的
方法就是创建其他的分支，然后按照一定的分支策略来管理我们的项目版本！一种最简单和
常用的分支策略就是：
在master分支上开辟一个新的develop分支，然后我们根据功能或者业务，再在develop
分支上另外开辟其他分支，完成分支上的任务后，再将这个分支合并到develop分支上！
master分支和develop分支都是长期分支，而我们创建的其他分支则是临时性分支！
简单概括下各个分支都拿来干嘛吧：
master分支：可直接用于产品发布的代码，就是正式版的代码
develop分支：日常开发用的分支，团队中的人都在这个分支上进行开发
临时性分支：根据特定目的开辟的分支，包括功能(feature)分支，或者预发布(release)分支，
又或者是修复bug（fixbug）分支，临时性分支用完之后一般都会删除，使得代码库的常用分支始终
只有两个长期分支！
PS:关于分支管理的详细策略，我们后面讲多人协作再细讲，这里知道最简单的这种就可以了！